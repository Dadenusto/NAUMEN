     * Поиск кратчайшего маршрута между двумя точками
     * Поиск будет проводится при помощи алгоритма Ли
     * Создается массив new_map типа int размерности как у map
     * В матрицу 2х2 start_goal типа int запишем координаты '@' и 'X' соотвествеено
     * Записываем данные в new_map по следующему правилу:
     * где в map '@' в new_map 0
     * где в map '.' в new_map -1
     * где в map '#' в new_map -2
     * где в map 'X' в new_map -3
     * Массив way типа int размерности 2 будет хранить координаты точки, из которой попадаем в 'X'
     * В цикле do while производим построение лаберинта по алгоритму Ли:
     * 0)задаем начальный параметр d = 0
     * 1)задаем параметр stop=false
     * 2)ищем элемент, равный d
     * 3.1)если не найден, прекращаем цикл
     * 3.2)если найден, то соседним точкам по горизонтале и вертикали ставим значение d+1 и stop=false
     * 3.3)если одна из соседних точек является -3, т.е. 'X', то way ставим значения точки,
     * 4)проверяем на критерий остонва: если way != {-1, -1} и stop = false, то d++, возвращаемся к 1) (если stop=true, то значит, что было невозможно построить соседние точки для данного d), иначе 5
     * 5.1)если way == {-1, -1}, то возвращаем null
     * 5.2)иначе путь найден
     * 6)для точки с координатами way ищем среди соседних ту, значение которой на 1 меньше, присваеваем в map точке с координатами way '+'
     * 7.1)если соседняя точка является '@', то оставливаем цикл и возвращаем матрицу map с построенным путем
     * 7.2)иначе переходим в точку со значением на 1 меньше и возвращаемся к шагу 6

     *Уличшил алгоритм за счет прохода не по всему массиву данных, а только по необходимым точкам(так как начало - одно значения), от него можно построить максимум 4 новых и тд. Также где возможно, избавился от матриц и массивов, точки хранятся в едином массиве на (2k) и (2k+1) местах, вместо if..else где возможно использовал swich..case 
